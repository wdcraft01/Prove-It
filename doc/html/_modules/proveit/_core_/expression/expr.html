
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>proveit._core_.expression.expr &#8212; Prove-It 0.3 documentation</title>
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for proveit._core_.expression.expr</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is the expression module.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">proveit._core_.defaults</span> <span class="k">import</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">USE_DEFAULTS</span>
<span class="kn">from</span> <span class="nn">proveit._core_.context</span> <span class="k">import</span> <span class="n">Context</span>
<span class="kn">from</span> <span class="nn">proveit._core_.expression.style_options</span> <span class="k">import</span> <span class="n">StyleOptions</span>
<span class="kn">from</span> <span class="nn">proveit._core_._unique_data</span> <span class="k">import</span> <span class="n">meaningData</span><span class="p">,</span> <span class="n">styleData</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">urllib.request</span><span class="o">,</span> <span class="nn">urllib.parse</span><span class="o">,</span> <span class="nn">urllib.error</span>

<span class="k">class</span> <span class="nc">ExprType</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    By overriding the Expression type, we can make Operation-type</span>
<span class="sd">    expressions automatically populate the Operation.operationClassOfOperator</span>
<span class="sd">    dictionary as long as the relevent &#39;_operator_&#39; class attribute is </span>
<span class="sd">    accessed at least once.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.expression.operation</span> <span class="k">import</span> <span class="n">Operation</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Operation</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;_operator_&#39;</span><span class="p">:</span>
            <span class="n">Operation</span><span class="o">.</span><span class="n">operationClassOfOperator</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="k">return</span> <span class="n">value</span>

<div class="viewcode-block" id="Expression"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression">[docs]</a><span class="k">class</span> <span class="nc">Expression</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ExprType</span><span class="p">):</span>
    <span class="c1"># set of (style-id, Expression) tuples</span>
    <span class="n">displayed_expression_styles</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> 
    
    <span class="c1"># map expression style ids to contexts (for expressions that &quot;belong&quot; to a Context)</span>
    <span class="n">contexts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> 
    
    <span class="c1"># (expression, assumption) pairs for which conclude is in progress, tracked to prevent infinite</span>
    <span class="c1"># recursion in the `prove` method.</span>
    <span class="n">in_progress_to_conclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> 

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_clear_</span><span class="p">():</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Clear all references to Prove-It information under</span>
<span class="sd">        the Expression jurisdiction.  All Expression classes that store Prove-It</span>
<span class="sd">        state information must implement _clear_ to clear that information.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">Expression</span><span class="o">.</span><span class="n">displayed_expression_styles</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">Expression</span><span class="o">.</span><span class="n">contexts</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">Expression</span><span class="o">.</span><span class="n">in_progress_to_conclude</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Unexpected remnant &#39;in_progress_to_conclude&#39; items (should have been temporary)&quot;</span>
                        
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coreInfo</span><span class="p">,</span> <span class="n">subExpressions</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">styles</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span> <span class="n">requirements</span><span class="o">=</span><span class="nb">tuple</span><span class="p">()):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize an expression with the given coreInfo (information relevant at the core Expression-type</span>
<span class="sd">        level) which should be a list (or tuple) of strings, and a list (or tuple) of subExpressions.</span>
<span class="sd">        &quot;styles&quot; is a dictionary used to indicate how the Expression should be formatted</span>
<span class="sd">        when there are different possibilities (e.g. division with &#39;/&#39; or as a fraction).  The meaning</span>
<span class="sd">        of the expression is independent of its styles signature.</span>
<span class="sd">        The &quot;requirements&quot; are expressions that must be proven to be true in order for the Expression</span>
<span class="sd">        to make sense.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">coreInfoElem</span> <span class="ow">in</span> <span class="n">coreInfo</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coreInfoElem</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expecting coreInfo elements to be of string type&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">subExpression</span> <span class="ow">in</span> <span class="n">subExpressions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subExpression</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expecting subExpression elements to be of Expression type&#39;</span><span class="p">)</span>
                
        <span class="c1"># note: these contained expressions are subject to style changes on an Expression instance basis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subExpressions</span> <span class="o">=</span> <span class="n">subExpressions</span> 
        
        <span class="c1"># The meaning data is shared among Expressions with the same structure disregarding style</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span> <span class="o">=</span> <span class="n">meaningData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_unique_rep</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span> <span class="p">:</span> <span class="nb">hex</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">_meaning_id</span><span class="p">),</span> <span class="n">coreInfo</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="p">,</span> <span class="s1">&#39;_coreInfo&#39;</span><span class="p">):</span>
            <span class="c1"># initialize the data of self._meaningData</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_coreInfo</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coreInfo</span><span class="p">)</span>
            <span class="c1"># combine requirements from all sub-expressions</span>
            <span class="n">requirements</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">subExpression</span><span class="o">.</span><span class="n">getRequirements</span><span class="p">()</span> <span class="k">for</span> <span class="n">subExpression</span> <span class="ow">in</span> <span class="n">subExpressions</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">())</span> <span class="o">+</span> <span class="n">requirements</span>
            <span class="c1"># Expression requirements are essentially assumptions that need to be proven for the expression to</span>
            <span class="c1"># be valid.  Calling &quot;checkAssumptions&quot; will remove repeats and generate proof by assumption for each</span>
            <span class="c1"># (which may not be necessary, but does not hurt).   </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_requirements</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">checkedAssumptions</span><span class="p">(</span><span class="n">requirements</span><span class="p">)</span>
        
        <span class="c1"># The style data is shared among Expressions with the same structure and style -- this will contain the &#39;png&#39; generated on demand.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span> <span class="o">=</span> <span class="n">styleData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_unique_rep</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span> <span class="p">:</span> <span class="nb">hex</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">_style_id</span><span class="p">),</span> <span class="n">coreInfo</span><span class="p">,</span> <span class="n">styles</span><span class="p">))</span>
        <span class="c1"># initialize the style options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">styles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">styles</span><span class="p">)</span> <span class="c1"># formatting style options that don&#39;t affect the meaning of the expression</span>

        <span class="c1"># reference this unchanging data of the unique &#39;meaning&#39; data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_unique_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coreInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_coreInfo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_requirements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_requirements</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_style_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">_unique_id</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        self._styles = dict(styles) # formatting style options that don&#39;t affect the meaning of the expression</span>
<span class="sd">        # meaning representations and unique ids are independent of style</span>
<span class="sd">        self._meaning_rep = </span>
<span class="sd">        self._meaning_id = makeUniqueId(self._meaning_rep)</span>
<span class="sd">        # style representations and style ids are dependent of style</span>
<span class="sd">        self._style_rep = self._generate_unique_rep(lambda expr : hex(expr._style_id), includeStyle=True)</span>
<span class="sd">        self._style_id = makeUniqueId(self._style_rep)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">subExpression</span> <span class="ow">in</span> <span class="n">subExpressions</span><span class="p">:</span> <span class="c1"># update Expression.parent_expr_map</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">addChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subExpression</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_setContext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Assign a Context to this expression.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="n">Expression</span><span class="o">.</span><span class="n">contexts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_style_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">context</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # Commenting this out because this make a strange first-come, first-serve</span>
<span class="sd">        # context assignment that might keep changing expression representations around;</span>
<span class="sd">        # that can be a nuisance for version controlling the Prove-It notebooks.</span>
<span class="sd">        for sub_expr in self._subExpressions:</span>
<span class="sd">            if sub_expr._style_id not in Expression.contexts:</span>
<span class="sd">                sub_expr._setContext(context)</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">_generate_unique_rep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objectRepFn</span><span class="p">,</span> <span class="n">coreInfo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">styles</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generate a unique representation string using the given function to obtain representations of other referenced Prove-It objects.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">coreInfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">coreInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coreInfo</span>
        <span class="k">if</span> <span class="n">styles</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_styleData&#39;</span><span class="p">):</span>
            <span class="n">styles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">styles</span>
        <span class="n">style_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">styles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">style_str</span> <span class="o">=</span> <span class="s1">&#39;;[&#39;</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">style_name</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">styles</span><span class="p">[</span><span class="n">style_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">style_name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">styles</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_path</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">coreInfo</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span> <span class="o">+</span> <span class="n">style_str</span> <span class="o">+</span> <span class="s1">&#39;;[&#39;</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">objectRepFn</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subExpressions</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
    
    <span class="k">def</span> <span class="nf">_class_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ExprClass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">class_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">ExprClass</span><span class="o">.</span><span class="vm">__module__</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">class_module</span><span class="p">,</span> <span class="s1">&#39;__file__&#39;</span><span class="p">):</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">class_module</span><span class="o">.</span><span class="vm">__file__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">()</span> <span class="c1"># use the current directory if using the main module</span>
        <span class="c1"># get the full class path relative to the root context where the class is defined</span>
        <span class="n">class_path</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">ExprClass</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">ExprClass</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="n">class_path</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extractExprClass</span><span class="p">(</span><span class="n">unique_rep</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the class of the Expression with the given unique representation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">unique_rep</span><span class="p">[:</span><span class="n">unique_rep</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extractCoreInfo</span><span class="p">(</span><span class="n">unique_rep</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the core information of the given unique representation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">unique_rep</span><span class="p">[</span><span class="n">unique_rep</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">unique_rep</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">)])</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extractStyle</span><span class="p">(</span><span class="n">unique_rep</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the style information of the given unique representation assuming the style was included.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">style_str</span> <span class="o">=</span> <span class="n">unique_rep</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">style_pairs</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;\[|,|\]&quot;</span><span class="p">,</span><span class="n">style_str</span><span class="p">)</span> 
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">style_pair</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">style_pair</span> <span class="ow">in</span> <span class="n">style_pairs</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">style_pair</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extractReferencedObjIds</span><span class="p">(</span><span class="n">unique_rep</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a unique representation string, returns the list of representations</span>
<span class="sd">        of Prove-It objects that are referenced.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># After the &#39;;&#39; comes the list of sub-Expressions.</span>
        <span class="n">subExprs</span> <span class="o">=</span> <span class="n">unique_rep</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">objIds</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;\[|,|\]&quot;</span><span class="p">,</span><span class="n">subExprs</span><span class="p">)</span> 
        <span class="k">return</span> <span class="p">[</span><span class="n">objId</span> <span class="k">for</span> <span class="n">objId</span> <span class="ow">in</span> <span class="n">objIds</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">objId</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>  
    
    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Expressions should be read-only objects.  Attributes may be added, however; for example,</span>
<span class="sd">        the &#39;png&#39; attribute which will be added whenever it is generated).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Attempting to alter read-only value &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span><span class="o">%</span><span class="n">attr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># just use the string representation</span>
    
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_meaning_id</span> 
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span> <span class="c1"># other must be an Expression to be equal to self</span>
    
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_id</span> 
    
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a string representation of the Expression.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">()</span>
    
<div class="viewcode-block" id="Expression.string"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.string">[docs]</a>    <span class="k">def</span> <span class="nf">string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a string representation of the Expression.  The kwargs can contain formatting</span>
<span class="sd">        directives (such as &#39;fence&#39; used to indicate when a sub-expression should be wrapped in</span>
<span class="sd">        parentheses if there can be ambiguity in the order of operations).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;string&#39; method not implemented for &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span></div>

<div class="viewcode-block" id="Expression.latex"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.latex">[docs]</a>    <span class="k">def</span> <span class="nf">latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a latex-formatted representation of the Expression.  The kwargs can contain formatting</span>
<span class="sd">        directives (such as &#39;fence&#39; used to indicate when a sub-expression should be wrapped in</span>
<span class="sd">        parentheses if there can be ambiguity in the order of operations).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;latex&#39; method not implemented for &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="Expression.formatted"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.formatted">[docs]</a>    <span class="k">def</span> <span class="nf">formatted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formatType</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a formatted version of the expression for the given formatType</span>
<span class="sd">        (&#39;string&#39; or &#39;latex&#39;).  In the keyword arguments, fence=True indicates</span>
<span class="sd">        that parenthesis around the sub-expression may be necessary to avoid </span>
<span class="sd">        ambiguity.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">formatType</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">formatType</span> <span class="o">==</span> <span class="s1">&#39;latex&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_make</span><span class="p">(</span><span class="n">subClass</span><span class="p">,</span> <span class="n">coreInfo</span><span class="p">,</span> <span class="n">styles</span><span class="p">,</span> <span class="n">subExpressions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Should make the Expression object for the specific Expression sub-class based upon the coreInfo</span>
<span class="sd">        and subExpressions.  Must be implemented for each core Expression sub-class that can be instantiated.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="n">MakeNotImplemented</span><span class="p">(</span><span class="n">subClass</span><span class="p">)</span>
                    
<div class="viewcode-block" id="Expression.coreInfo"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.coreInfo">[docs]</a>    <span class="k">def</span> <span class="nf">coreInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Copy out the core information.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coreInfo</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Expression.subExpr"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.subExpr">[docs]</a>    <span class="k">def</span> <span class="nf">subExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subExpressions</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>
        
<div class="viewcode-block" id="Expression.subExprIter"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.subExprIter">[docs]</a>    <span class="k">def</span> <span class="nf">subExprIter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Iterator over the sub-expressions of this expression.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subExpressions</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Expression.numSubExpr"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.numSubExpr">[docs]</a>    <span class="k">def</span> <span class="nf">numSubExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the number of sub-expressions of this expression.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subExpressions</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Expression.innerExpr"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.innerExpr">[docs]</a>    <span class="k">def</span> <span class="nf">innerExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return an InnerExpr object to wrap the expression and</span>
<span class="sd">        access any inner sub-expression for the purpose of creating</span>
<span class="sd">        a lambda expression to replace the inner expression within</span>
<span class="sd">        this one or change its styles.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.inner_expr</span> <span class="k">import</span> <span class="n">InnerExpr</span>
        <span class="k">return</span> <span class="n">InnerExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Expression.styleOptions"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.styleOptions">[docs]</a>    <span class="k">def</span> <span class="nf">styleOptions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a StyleOptions object that indicates the possible</span>
<span class="sd">        styles and values that is available to determine how</span>
<span class="sd">        this Expression may be presented.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">StyleOptions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># the default is empty</span></div>
    
<div class="viewcode-block" id="Expression.withStyles"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.withStyles">[docs]</a>    <span class="k">def</span> <span class="nf">withStyles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Alter the styles of this expression, and anything containing this</span>
<span class="sd">        particular expression object, according to kwargs.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">styles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">styles</span><span class="p">)</span>
        <span class="c1"># update the _styles, _style_rep, and _style_id</span>
        <span class="n">styles</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">styles</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">styles</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="c1"># no change in styles, so just use the original</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">updateStyles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">styles</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    
<div class="viewcode-block" id="Expression.withMatchingStyle"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.withMatchingStyle">[docs]</a>    <span class="k">def</span> <span class="nf">withMatchingStyle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr_with_different_style</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Alter the styles of this expression to match that of the</span>
<span class="sd">        given &quot;expr_with_different_style&quot;.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">!=</span> <span class="n">expr_with_different_style</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;withMatchingStyle&#39; must be given an expression with the same meaning&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_style_id</span> <span class="o">==</span> <span class="n">expr_with_different_style</span><span class="o">.</span><span class="n">_style_id</span><span class="p">:</span>
            <span class="k">return</span> <span class="c1"># no difference in style actually; do nothing</span>
        <span class="k">for</span> <span class="n">my_sub_expr</span><span class="p">,</span> <span class="n">other_sub_expr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subExprIter</span><span class="p">(),</span> <span class="n">expr_with_different_style</span><span class="o">.</span><span class="n">subExprIter</span><span class="p">()):</span>
            <span class="n">my_sub_expr</span><span class="o">.</span><span class="n">withMatchingStyle</span><span class="p">(</span><span class="n">other_sub_expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">withStyles</span><span class="p">(</span><span class="o">**</span><span class="n">expr_with_different_style</span><span class="o">.</span><span class="n">getStyles</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    
<div class="viewcode-block" id="Expression.styleNames"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.styleNames">[docs]</a>    <span class="k">def</span> <span class="nf">styleNames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the name of the styles that may be set.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">styles</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>
    
<div class="viewcode-block" id="Expression.getStyle"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.getStyle">[docs]</a>    <span class="k">def</span> <span class="nf">getStyle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">styleName</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the current style setting for the given style name.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">styles</span><span class="p">[</span><span class="n">styleName</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="Expression.getStyles"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.getStyles">[docs]</a>    <span class="k">def</span> <span class="nf">getStyles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a copy of the internally maintained styles dictionary.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">styles</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Expression.getRequirements"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.getRequirements">[docs]</a>    <span class="k">def</span> <span class="nf">getRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a copy of the requirements.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_requirements</span><span class="p">)</span></div>
     
<div class="viewcode-block" id="Expression.remakeConstructor"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.remakeConstructor">[docs]</a>    <span class="k">def</span> <span class="nf">remakeConstructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Method to call to reconstruct this Expression.  The default is the class name</span>
<span class="sd">        itself to use the __init__ method, but sometimes a different method is more</span>
<span class="sd">        appropriate for setting the proper style (e.g. the Frac method in </span>
<span class="sd">        proveit.number.division.divide which constructs a Div object with a different</span>
<span class="sd">        style).  This constructor method must be in the same module as the class.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span></div>
    
<div class="viewcode-block" id="Expression.remakeArguments"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.remakeArguments">[docs]</a>    <span class="k">def</span> <span class="nf">remakeArguments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Yield the argument values or (name, value) pairs</span>
<span class="sd">        that could be used to recreate the Expression.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;remakeArguments method should be implemented for all ProveIt core Expression sub-classes.&quot;</span><span class="p">)</span></div>
            
<div class="viewcode-block" id="Expression.remakeWithStyleCalls"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.remakeWithStyleCalls">[docs]</a>    <span class="k">def</span> <span class="nf">remakeWithStyleCalls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        In order to reconstruct this Expression to have the same styles,</span>
<span class="sd">        what &quot;with...&quot; method calls are most appropriate?  Return a </span>
<span class="sd">        tuple of strings with the calls to make.  For example,</span>
<span class="sd">        [&quot;withWrappingAt(3)&quot;, &quot;withJustification(&#39;right&#39;)&quot;].</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="Expression.prove"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.prove">[docs]</a>    <span class="k">def</span> <span class="nf">prove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">,</span> <span class="n">automation</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Attempt to prove this expression automatically under the</span>
<span class="sd">        given assumptions (if None, uses defaults.assumptions).  First</span>
<span class="sd">        it tries to find an existing KnownTruth, then it tries a simple</span>
<span class="sd">        proof by assumption (if self is contained in the assumptions),</span>
<span class="sd">        then it attempts to call the &#39;conclude&#39; method.  If successful,</span>
<span class="sd">        the KnownTruth is returned, otherwise an exception is raised.</span>
<span class="sd">        Cyclic attempts to `conclude` the same expression under the</span>
<span class="sd">        same set of assumptions will be blocked, so `conclude` methods are</span>
<span class="sd">        free make attempts that may be cyclic.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">KnownTruth</span><span class="p">,</span> <span class="n">ProofFailure</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">Not</span>
        <span class="n">assumptions</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">checkedAssumptions</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="n">assumptionsSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">automation</span> <span class="ow">is</span> <span class="n">USE_DEFAULTS</span><span class="p">:</span>
            <span class="n">automation</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">automation</span>
                
        <span class="c1"># Note: exclude WILDCARD_ASSUMPTIONS when looking for an existing proof.</span>
        <span class="c1">#   (may not matter, but just in case).</span>
        <span class="n">foundTruth</span> <span class="o">=</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">findKnownTruth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">assumptionsSet</span> <span class="o">-</span> <span class="p">{</span><span class="s1">&#39;*&#39;</span><span class="p">}))</span>
        <span class="k">if</span> <span class="n">foundTruth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">foundTruth</span><span class="o">.</span><span class="n">withMatchingStyles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">)</span> <span class="c1"># give it the appropriate style</span>
            <span class="k">return</span> <span class="n">foundTruth</span> <span class="c1"># found an existing KnownTruth that does the job!</span>
                
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">assumptionsSet</span> <span class="ow">or</span> <span class="s1">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">assumptionsSet</span><span class="p">:</span>
            <span class="c1"># prove by assumption if self is in the list of assumptions or</span>
            <span class="c1"># WILDCARD_ASSUMPTIONS is in the list of assumptions.</span>
            <span class="kn">from</span> <span class="nn">proveit._core_.proof</span> <span class="k">import</span> <span class="n">Assumption</span>
            <span class="k">return</span> <span class="n">Assumption</span><span class="o">.</span><span class="n">makeAssumption</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">)</span><span class="o">.</span><span class="n">provenTruth</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">automation</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProofFailure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">,</span> <span class="s2">&quot;No pre-existing proof&quot;</span><span class="p">)</span>
                                                
        <span class="c1"># Use Expression.in_progress_to_conclude set to prevent an infinite recursion</span>
        <span class="n">in_progress_key</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span><span class="nb">hash</span><span class="p">(</span><span class="n">expr</span><span class="p">))))</span>
        <span class="k">if</span> <span class="n">in_progress_key</span> <span class="ow">in</span> <span class="n">Expression</span><span class="o">.</span><span class="n">in_progress_to_conclude</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProofFailure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">,</span> <span class="s2">&quot;Infinite &#39;conclude&#39; recursion blocked.&quot;</span><span class="p">)</span>
        <span class="n">Expression</span><span class="o">.</span><span class="n">in_progress_to_conclude</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">in_progress_key</span><span class="p">)</span>        
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">concludedTruth</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Not</span><span class="p">):</span>
                <span class="c1"># if it is a Not expression, try concludeNegation on the operand</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">concludedTruth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">concludeNegation</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="n">assumptions</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                    <span class="k">pass</span> <span class="c1"># that didn&#39;t work, try conclude on the Not expression itself</span>
            <span class="k">if</span> <span class="n">concludedTruth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># first attempt to prove via implication</span>
                    <span class="n">concludedTruth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concludeViaImplication</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ProofFailure</span><span class="p">:</span>
                    <span class="c1"># try the &#39;conclude&#39; method of the specific Expression class</span>
                    <span class="n">concludedTruth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conclude</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">concludedTruth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ProofFailure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">,</span> <span class="s2">&quot;Failure to automatically &#39;conclude&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">concludedTruth</span><span class="p">,</span> <span class="n">KnownTruth</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;conclude&#39; method should return a KnownTruth (or raise an exception)&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">concludedTruth</span><span class="o">.</span><span class="n">expr</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;conclude&#39; method should return a KnownTruth for this Expression object: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">concludedTruth</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; does not match &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">concludedTruth</span><span class="o">.</span><span class="n">assumptionsSet</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">assumptionsSet</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;While proving &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &#39;conclude&#39; method returned a KnownTruth with extra assumptions: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">concludedTruth</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span> <span class="o">-</span> <span class="n">assumptionsSet</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">concludedTruth</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_style_id</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_style_id</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">concludedTruth</span> <span class="c1"># concludedTruth with the same style as self.</span>
            <span class="k">return</span> <span class="n">concludedTruth</span><span class="o">.</span><span class="n">withMatchingStyles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">)</span> <span class="c1"># give it the appropriate style</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProofFailure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">,</span> <span class="s2">&quot;&#39;conclude&#39; method not implemented for proof automation&quot;</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">Expression</span><span class="o">.</span><span class="n">in_progress_to_conclude</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">in_progress_key</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expression.disprove"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.disprove">[docs]</a>    <span class="k">def</span> <span class="nf">disprove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">,</span> <span class="n">automation</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Attempt to prove the logical negation (Not) of this expression. </span>
<span class="sd">        If successful, the KnownTruth is returned, otherwise an exception</span>
<span class="sd">        is raised.  By default, this simply calls prove on the negated</span>
<span class="sd">        expression. Override `concludeNegation` for automation specific to</span>
<span class="sd">        the type of expression being negated.      </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">Not</span>
        <span class="k">return</span> <span class="n">Not</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="n">assumptions</span><span class="p">,</span> <span class="n">automation</span><span class="o">=</span><span class="n">automation</span><span class="p">)</span></div>
                        
<div class="viewcode-block" id="Expression.conclude"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.conclude">[docs]</a>    <span class="k">def</span> <span class="nf">conclude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Attempt to conclude this expression under the given assumptions, </span>
<span class="sd">        using automation specific to this type of expression.</span>
<span class="sd">        Return the KnownTruth if successful, or raise an exception.</span>
<span class="sd">        This is called by the `prove` method when no existing proof was found </span>
<span class="sd">        and it cannot be proven trivially via assumption or defaultConclude.</span>
<span class="sd">        The `prove` method has a mechanism to prevent infinite recursion, </span>
<span class="sd">        so there are no worries regarding cyclic attempts to conclude an expression.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;conclude&#39; not implemented for &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span></div>

<div class="viewcode-block" id="Expression.concludeViaImplication"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.concludeViaImplication">[docs]</a>    <span class="k">def</span> <span class="nf">concludeViaImplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Attempt to conclude this expression via applying</span>
<span class="sd">        modus ponens of known implications.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">concludeViaImplication</span>
        <span class="k">return</span> <span class="n">concludeViaImplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Expression.concludeNegation"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.concludeNegation">[docs]</a>    <span class="k">def</span> <span class="nf">concludeNegation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Attempt to conclude the negation of this expression under the given</span>
<span class="sd">        assumptions, using automation specific to the type of expression being negated.</span>
<span class="sd">        Return the KnownTruth if successful, or raise an exception.</span>
<span class="sd">        This is called by the `prove` method of the negated expression</span>
<span class="sd">        when no existing proof for the negation was found.</span>
<span class="sd">        The `prove` method has a mechanism to prevent infinite recursion, </span>
<span class="sd">        so there are no worries regarding cyclic attempts to conclude an expression.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;concludeNegation&#39; not implemented for &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span></div>
        
<div class="viewcode-block" id="Expression.sideEffects"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.sideEffects">[docs]</a>    <span class="k">def</span> <span class="nf">sideEffects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">knownTruth</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Yield methods to attempt as side-effects when this expression</span>
<span class="sd">        is proven as a known truth.  These should each accept an</span>
<span class="sd">        &#39;assumptions&#39; parameter.</span>
<span class="sd">        These should be obvious and useful consequences, trivial and limited.</span>
<span class="sd">        There is no need to call this manually; it is called automatically when</span>
<span class="sd">        the corresponding KnownTruth is created.</span>
<span class="sd">        It also may be desirable to store the knownTruth for future automation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span></div>
    
<div class="viewcode-block" id="Expression.substituted"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.substituted">[docs]</a>    <span class="k">def</span> <span class="nf">substituted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprMap</span><span class="p">,</span> <span class="n">relabelMap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reservedVars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns this expression with the expressions substituted </span>
<span class="sd">        according to the exprMap dictionary (mapping Expressions to Expressions --</span>
<span class="sd">        for specialize, this may only map Variables to Expressions).</span>
<span class="sd">        If supplied, reservedVars is a dictionary that maps reserved Variable&#39;s</span>
<span class="sd">        to relabeling exceptions.  You cannot substitute with an expression that</span>
<span class="sd">        uses a restricted variable and you can only relabel the exception to the</span>
<span class="sd">        restricted variable.  This is used to protect an Lambda function&#39;s &quot;scope&quot;.</span>
<span class="sd">        </span>
<span class="sd">        For certain Expression classes in proveit._core_.expression.composite,</span>
<span class="sd">        intermediate proofs may be required.  This is why assumptions may be</span>
<span class="sd">        needed.  If a list is passed into requirements, KnownTruth&#39;s for these</span>
<span class="sd">        intermediate proofs will be appended to it -- these are requirements</span>
<span class="sd">        for the substitution to be valid.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkRelabelMap</span><span class="p">(</span><span class="n">relabelMap</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">exprMap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">in</span> <span class="n">exprMap</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">exprMap</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span><span class="o">.</span><span class="n">_restrictionChecked</span><span class="p">(</span><span class="n">reservedVars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span></div>
    
<div class="viewcode-block" id="Expression.relabeled"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.relabeled">[docs]</a>    <span class="k">def</span> <span class="nf">relabeled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relabelMap</span><span class="p">,</span> <span class="n">reservedVars</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A watered down version of substituted in which only variable labels are</span>
<span class="sd">        changed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substituted</span><span class="p">(</span><span class="n">exprMap</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span> <span class="n">relabelMap</span><span class="o">=</span><span class="n">relabelMap</span><span class="p">,</span> <span class="n">reservedVars</span><span class="o">=</span><span class="n">reservedVars</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="nf">_checkRelabelMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relabelMap</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Make sure that all of the relabelMap keys are Variable objects</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">Variable</span>
        <span class="k">if</span> <span class="n">relabelMap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">relabelMap</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;relabelMap keys must be Variables&quot;</span><span class="p">)</span>
    
<div class="viewcode-block" id="Expression.copy"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Make a copy of the Expression with the same styles.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">expr_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substituted</span><span class="p">(</span><span class="n">exprMap</span><span class="o">=</span><span class="nb">dict</span><span class="p">())</span> <span class="c1"># vacuous substitution makes a copy</span>
        <span class="k">return</span> <span class="n">expr_copy</span></div>

    <span class="k">def</span> <span class="nf">_expandingIterRanges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterParams</span><span class="p">,</span> <span class="n">startArgs</span><span class="p">,</span> <span class="n">endArgs</span><span class="p">,</span> <span class="n">exprMap</span><span class="p">,</span> <span class="n">relabelMap</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reservedVars</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # raise _NoExpandedIteration by default.</span>
<span class="sd">        # Overridden by Indexed, Operation, and ExprList.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="n">_NoExpandedIteration</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">_validateRelabelMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relabelMap</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">relabelMap</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">relabelMap</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="k">raise</span> <span class="n">ImproperRelabeling</span><span class="p">(</span><span class="s2">&quot;Cannot relabel different Variables to the same Variable.&quot;</span><span class="p">)</span>
    
<div class="viewcode-block" id="Expression.usedVars"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.usedVars">[docs]</a>    <span class="k">def</span> <span class="nf">usedVars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the union of the used Variables of the sub-Expressions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">usedVars</span><span class="p">()</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subExprIter</span><span class="p">()])</span></div>
        
<div class="viewcode-block" id="Expression.freeVars"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.freeVars">[docs]</a>    <span class="k">def</span> <span class="nf">freeVars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the union of the free Variables of the sub-Expressions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">freeVars</span><span class="p">()</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subExprIter</span><span class="p">()])</span></div>

<div class="viewcode-block" id="Expression.freeMultiVars"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.freeMultiVars">[docs]</a>    <span class="k">def</span> <span class="nf">freeMultiVars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the used multi-variables that are not bound as an instance variable</span>
<span class="sd">        or wrapped in a Bundle (see multiExpression.py).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>    </div>

<div class="viewcode-block" id="Expression.safeDummyVar"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.safeDummyVar">[docs]</a>    <span class="k">def</span> <span class="nf">safeDummyVar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.expression.label.var</span> <span class="k">import</span> <span class="n">safeDummyVar</span>
        <span class="k">return</span> <span class="n">safeDummyVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expression.safeDummyVars"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.safeDummyVars">[docs]</a>    <span class="k">def</span> <span class="nf">safeDummyVars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.expression.label.var</span> <span class="k">import</span> <span class="n">safeDummyVars</span>
        <span class="k">return</span> <span class="n">safeDummyVars</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>
            
<div class="viewcode-block" id="Expression.evaluation"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.evaluation">[docs]</a>    <span class="k">def</span> <span class="nf">evaluation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        If possible, return a KnownTruth of this expression equal to its</span>
<span class="sd">        irreducible value.  Override for other appropriate functionality.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">defaultSimplification</span>
        <span class="k">return</span> <span class="n">defaultSimplification</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">innerExpr</span><span class="p">(),</span> <span class="n">inPlace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mustEvaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">assumptions</span><span class="p">)</span></div>

<div class="viewcode-block" id="Expression.simplification"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.simplification">[docs]</a>    <span class="k">def</span> <span class="nf">simplification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        If possible, return a KnownTruth of this expression equal to its</span>
<span class="sd">        irreducible value.  Override for other appropriate functionality.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">defaultSimplification</span>
        <span class="k">return</span> <span class="n">defaultSimplification</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">innerExpr</span><span class="p">(),</span> <span class="n">inPlace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">assumptions</span><span class="p">)</span>        </div>
    
<div class="viewcode-block" id="Expression.orderOfAppearance"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.orderOfAppearance">[docs]</a>    <span class="k">def</span> <span class="nf">orderOfAppearance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subExpressions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Yields the given sub-Expressions in the order in which they</span>
<span class="sd">        appear in this Expression.  There may be repeats.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">subExpressions</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">subExpr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subExpressions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">subExpr</span><span class="o">.</span><span class="n">orderOfAppearance</span><span class="p">(</span><span class="n">subExpressions</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">expr</span></div>
        
    <span class="k">def</span> <span class="nf">_restrictionChecked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reservedVars</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Check that a substituted expression (self) does not use any reserved variables</span>
<span class="sd">        (parameters of a Lambda function Expression).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reservedVars</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">freeVars</span><span class="p">()</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">reservedVars</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="k">raise</span> <span class="n">ScopingViolation</span><span class="p">(</span><span class="s2">&quot;Must not make substitution with reserved variables  (i.e., parameters of a Lambda function)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unofficialNameKindContext</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generate html to show a png compiled from the latex (that may be recalled</span>
<span class="sd">        from memory or storage if it was generated previously) with a link to</span>
<span class="sd">        an expr.ipynb notebook for displaying the expression information.</span>
<span class="sd">        If &#39;context&#39; is provided, find the stored expression information in</span>
<span class="sd">        that context; otherwise, use the default, current directory Context.</span>
<span class="sd">        If &#39;unofficialNameKindContext&#39; is provided, it should be the </span>
<span class="sd">        (name, kind, context) for a special expression that is not-yet-official</span>
<span class="sd">        (%end_[common/axioms/theorems] has not been called yet in the special </span>
<span class="sd">        expressions notebook).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="p">,</span><span class="s1">&#39;png&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">png</span><span class="p">,</span> <span class="n">png_url</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">_stored_png</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">latex</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config_latex_tool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">png_url</span> <span class="o">=</span> <span class="n">png_url</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">png_url</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">expr_notebook_rel_url</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">expressionNotebook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unofficialNameKindContext</span><span class="p">)</span>
            <span class="n">html</span> <span class="o">=</span> <span class="s1">&#39;&lt;a class=&quot;ProveItLink&quot; href=&quot;&#39;</span> <span class="o">+</span> <span class="n">expr_notebook_rel_url</span> <span class="o">+</span> <span class="s1">&#39;&quot;&gt;&#39;</span>
            <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;&lt;img src=&quot;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">png_url</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;&quot; style=&quot;display:inline;vertical-align:middle;&quot; /&gt;&#39;</span>
            <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;&lt;/a&gt;&#39;</span>
        <span class="c1"># record as a &quot;displayed&quot; (style-specific) expression</span>
        <span class="n">Expression</span><span class="o">.</span><span class="n">displayed_expression_styles</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_style_id</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span> 
        <span class="k">return</span> <span class="n">html</span>
        
    <span class="k">def</span> <span class="nf">_config_latex_tool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lt</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Configure the LaTeXTool from IPython.lib.latextools as required by all</span>
<span class="sd">        sub-expressions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">sub_expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subExpressions</span><span class="p">:</span>
            <span class="n">sub_expr</span><span class="o">.</span><span class="n">_config_latex_tool</span><span class="p">(</span><span class="n">lt</span><span class="p">)</span>

<div class="viewcode-block" id="Expression.exprInfo"><a class="viewcode-back" href="../../../../api/proveit.Expression.html#proveit.Expression.exprInfo">[docs]</a>    <span class="k">def</span> <span class="nf">exprInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">details</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.expression.expr_info</span> <span class="k">import</span> <span class="n">ExpressionInfo</span>
        <span class="k">return</span> <span class="n">ExpressionInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">details</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="expressionDepth"><a class="viewcode-back" href="../../../../api/proveit.expressionDepth.html#proveit.expressionDepth">[docs]</a><span class="k">def</span> <span class="nf">expressionDepth</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns the depth of the expression tree for the given expression.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">subDepths</span> <span class="o">=</span> <span class="p">[</span><span class="n">expressionDepth</span><span class="p">(</span><span class="n">subExpr</span><span class="p">)</span> <span class="k">for</span> <span class="n">subExpr</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">subExprIter</span><span class="p">()]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subDepths</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> 
        <span class="k">return</span> <span class="mi">1</span> <span class="c1"># no sub-expressions</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">subDepths</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># add 1 to the maximum of the sub-expression depths</span></div>

<div class="viewcode-block" id="MakeNotImplemented"><a class="viewcode-back" href="../../../../api/proveit.MakeNotImplemented.html#proveit.MakeNotImplemented">[docs]</a><span class="k">class</span> <span class="nc">MakeNotImplemented</span><span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprSubClass</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exprSubClass</span> <span class="o">=</span> <span class="n">exprSubClass</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;make method not implemented for &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exprSubClass</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImproperSubstitution"><a class="viewcode-back" href="../../../../api/proveit.ImproperSubstitution.html#proveit.ImproperSubstitution">[docs]</a><span class="k">class</span> <span class="nc">ImproperSubstitution</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span></div>

<div class="viewcode-block" id="ImproperRelabeling"><a class="viewcode-back" href="../../../../api/proveit.ImproperRelabeling.html#proveit.ImproperRelabeling">[docs]</a><span class="k">class</span> <span class="nc">ImproperRelabeling</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span></div>

<div class="viewcode-block" id="ScopingViolation"><a class="viewcode-back" href="../../../../api/proveit.ScopingViolation.html#proveit.ScopingViolation">[docs]</a><span class="k">class</span> <span class="nc">ScopingViolation</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span></div>

<span class="k">class</span> <span class="nc">_NoExpandedIteration</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Used internally for _expandingIterRanges.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
    
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">Prove-It</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.asExpression.html">asExpression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.asExpressions.html">asExpressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.compositeExpression.html">compositeExpression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.expressionDepth.html">expressionDepth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.maybeFenced.html">maybeFenced</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.maybeFencedLatex.html">maybeFencedLatex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.maybeFencedString.html">maybeFencedString</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.reset.html">reset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.safeDefaultOrDummyVar.html">safeDefaultOrDummyVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.safeDummyVar.html">safeDummyVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.singleOrCompositeExpression.html">singleOrCompositeExpression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.varIter.html">varIter</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Assumption.html">Assumption</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Axiom.html">Axiom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Composite.html">Composite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Context.html">Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ContextException.html">ContextException</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.DuplicateLiteralError.html">DuplicateLiteralError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprList.html">ExprList</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprListError.html">ExprListError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprTensor.html">ExprTensor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Expression.html">Expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Function.html">Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Generalization.html">Generalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.GeneralizationFailure.html">GeneralizationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.HypotheticalReasoning.html">HypotheticalReasoning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ImproperRelabeling.html">ImproperRelabeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ImproperSubstitution.html">ImproperSubstitution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Indexed.html">Indexed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.IndexedError.html">IndexedError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InnerExpr.html">InnerExpr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InvalidAssumptions.html">InvalidAssumptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Iter.html">Iter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.KnownTruth.html">KnownTruth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Label.html">Label</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Lambda.html">Lambda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.LambdaError.html">LambdaError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Literal.html">Literal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.MakeNotImplemented.html">MakeNotImplemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ModusPonens.html">ModusPonens</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ModusPonensFailure.html">ModusPonensFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.NamedExprs.html">NamedExprs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Operation.html">Operation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.OperationError.html">OperationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.OperationOverInstances.html">OperationOverInstances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.OperationSequence.html">OperationSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ParameterExtractionError.html">ParameterExtractionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Proof.html">Proof</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ProofFailure.html">ProofFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.RelabelingFailure.html">RelabelingFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ScopingViolation.html">ScopingViolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Specialization.html">Specialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.SpecializationFailure.html">SpecializationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.StyleOptions.html">StyleOptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Theorem.html">Theorem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TransitiveRelation.html">TransitiveRelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TransitiveSequence.html">TransitiveSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Variable.html">Variable</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.compose.html">compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.concludeViaImplication.html">concludeViaImplication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.defaultSimplification.html">defaultSimplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.evaluateTruth.html">evaluateTruth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.inBool.html">inBool</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.isIrreducibleValue.html">isIrreducibleValue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.reduceOperands.html">reduceOperands</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.And.html">And</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Card.html">Card</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Difference.html">Difference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Disjoint.html">Disjoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Distinct.html">Distinct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Equals.html">Equals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.EvaluationError.html">EvaluationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Exists.html">Exists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Forall.html">Forall</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Iff.html">Iff</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Implies.html">Implies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.InSet.html">InSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Intersect.html">Intersect</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.IrreducibleValue.html">IrreducibleValue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Membership.html">Membership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Nonmembership.html">Nonmembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Not.html">Not</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotEquals.html">NotEquals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotExists.html">NotExists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotInSet.html">NotInSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotSubsetEq.html">NotSubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotSupersetEq.html">NotSupersetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Or.html">Or</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetOfAll.html">SetOfAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Subset.html">Subset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SubsetEq.html">SubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Superset.html">Superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SupersetEq.html">SupersetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Union.html">Union</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Frac.html">Frac</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.GreaterEqOnlySeq.html">GreaterEqOnlySeq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.GreaterOnlySeq.html">GreaterOnlySeq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.LessEqOnlySeq.html">LessEqOnlySeq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.LessOnlySeq.html">LessOnlySeq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.greaterSequence.html">greaterSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.isLiteralInt.html">isLiteralInt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.lesserSequence.html">lesserSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.num.html">num</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Abs.html">Abs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Add.html">Add</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Ceil.html">Ceil</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.DecimalSequence.html">DecimalSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Div.html">Div</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Exp.html">Exp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Floor.html">Floor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Greater.html">Greater</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.GreaterEq.html">GreaterEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.GreaterSequence.html">GreaterSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Integrate.html">Integrate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Interval.html">Interval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.IntervalCC.html">IntervalCC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.IntervalCO.html">IntervalCO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.IntervalOC.html">IntervalOC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.IntervalOO.html">IntervalOO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Len.html">Len</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Less.html">Less</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.LessEq.html">LessEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.LesserSequence.html">LesserSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Max.html">Max</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Min.html">Min</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Mod.html">Mod</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.ModAbs.html">ModAbs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Mult.html">Mult</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Neg.html">Neg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Numeral.html">Numeral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.RealInterval.html">RealInterval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Round.html">Round</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Sqrt.html">Sqrt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Subtract.html">Subtract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.number.Sum.html">Sum</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  <li><a href="../../../proveit.html">proveit</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Wayne Witzel.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.9</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
    </div>

    

    
  </body>
</html>